What is a class in C++?
What is the purpose of a constructor in a class?
What is the difference between public and private access levels in a class?
What is the purpose of a destructor in a class?
What is the difference between syntax and linker errors during compilation?
What is a friend function in a class? How is it declared?
What is a conversion constructor in a class? How is it created?
What is the purpose of using the const keyword with classes and objects? Explain the different usages of const.
What is operator overloading in C++? Give some examples of operators that can be overloaded.
What is the difference between a member function and a non-member function when overloading an operator? How are binary and unary operators treated differently in operator overloading?
Answers:

A class in C++ is a user-defined data type that defines a blueprint for creating objects. It consists of member variables (also known as attributes) and member functions (also known as methods) that define the behavior of objects of that class.
The purpose of a constructor in a class is to initialize the member variables of an object when it is created. It has the same name as the class and no return type, and can take parameters to customize the initialization of the object.
Public and private are access levels in a class that determine whether member variables and member functions are accessible from outside the class. Public members can be accessed by any code that has access to the object of the class, while private members can only be accessed by member functions of the same class.
The purpose of a destructor in a class is to clean up the resources used by an object when it is destroyed (i.e., when it goes out of scope or is deleted). It has the same name as the class, but with a tilde (~) prefix, and does not take any parameters.
Syntax errors occur during compilation when there is a violation of the C++ language rules, while linker errors occur when the linker cannot find the definition of a function or variable that is used in the code.
A friend function in a class is a non-member function that has access to the private members of the class. It is declared in the class definition with the keyword "friend".
A conversion constructor in a class is a constructor that takes a single argument of a different type than the class itself. It allows automatic type conversion from the parameter type to the class type. It can be created by defining a constructor with a single parameter, and using the "explicit" keyword to prevent automatic type conversion if desired.
Using the const keyword with classes and objects provides protection from unintended modification of the object's state. It can be used in several ways:
Const reference parameters in member functions and friend functions: ensure that the parameter is not modified within the function.
Const member functions: indicate that the function does not modify the state of the object.
Const objects: declare an object as constant, so that only const member functions can be called on it.
Const member data: declare a member variable as constant, and initialize it with a special initialization list in the constructor.
Operator overloading in C++ is the ability to redefine the behavior of built-in operators (+, -, *, /, etc.) for user-defined types or classes. For example, the + operator can be overloaded to concatenate two strings. Other operators that can be overloaded include comparison operators (==, !=, <, >, <=, >=), insertion and extraction operators (<<, >>), increment and decrement operators (++, --), and many more.
When overloading an operator, a member function is

What is an array?
An array is a collection of similar data types stored in contiguous memory locations.
What is a class?
A class is a user-defined data type that encapsulates data and functions.
How do you declare an array of objects?
You can declare an array of objects by using the class name followed by square brackets and the number of elements in the array, like this: ClassName arrayName[numElements];
What is a default constructor?
A default constructor is a constructor that is automatically generated by the compiler if no constructor is defined in the class. It initializes the object's data members to their default values.
How do you initialize an array of objects?
You can initialize an array of objects by enclosing a comma-separated list of object initializations in curly braces and using the assignment operator, like this: ClassName arrayName[numElements] = { object1, object2, ... };
How do you access elements of an array of objects?
You can access elements of an array of objects using the subscript operator ([]) and the element's index, like this: arrayName[index].
How do you declare an array as a member data of a class?
You can declare an array as a member data of a class by including it in the class definition, like this: ClassName { dataType arrayName[numElements]; }.
What is a tracking variable?
A tracking variable is a variable that is used to keep track of how many elements in an array are currently being used.
What is the dot operator used for?
The dot operator is used to access the members of an object, like this: object.member.
What is dynamic memory allocation?
Dynamic memory allocation is the process of allocating memory during program execution, rather than at compile time.
What is the new operator used for?
The new operator is used to dynamically allocate memory for an object or array, like this: ClassName* ptrName = new ClassName;
What is the arrow operator used for?
The arrow operator is used to access the members of an object pointed to by a pointer, like this: ptrName->member.
How do you deallocate dynamically allocated memory?
You can deallocate dynamically allocated memory using the delete operator, like this: delete ptrName;
What is the difference between delete and delete[]?
The delete operator is used to deallocate memory for a single object allocated with new, while the delete[] operator is used to deallocate memory for an array of objects allocated with new[].
What is a copy constructor?
A copy constructor is a constructor that creates a new object by copying the values of an existing object.
When is a copy constructor invoked?
A copy constructor is invoked when a new object is created by copying an existing object, such as when an object is passed into a function by value or when an object is initialized with another object's value.
What is a shallow copy?
A shallow copy is a copy in which the pointers and references of the original object are copied verbatim to the new object. They end up pointing to the same attached data.
What is a deep copy?
A deep copy is a copy in which not only the pointers and references of the original object are copied, but also the attached data is copied to the new object.
What is the assignment operator?
The assignment operator is an operator that assigns the value of one object to another object.
How do you overload the assignment operator?
You can overload the assignment operator by defining a member function with the signature: ClassName& operator=(const ClassName& other).

Strings -- C-strings vs. string objects

What is the difference between C-strings and string objects?
A: C-strings are character arrays that terminate with a null character, while string objects are a class that provides various member functions to manipulate strings.

What is the main limitation of C-strings?
A: C-strings have a fixed length and can cause buffer overflow if the length of the string exceeds the allocated space.

What is the difference between dynamic allocation and static allocation for C-strings?
A: Dynamic allocation allows for the allocation of memory at runtime, while static allocation allocates memory at compile time.

What is the use of classes in building a "string" type?
A: Classes allow for the creation of a user-defined type that can store and manipulate strings.

What are the advantages of using a string object over C-strings?
A: String objects have dynamic size, automatic memory management, and a range of member functions for manipulating strings.

Inheritance - The Basics

What is the "is-a" relationship in inheritance?
A: The "is-a" relationship refers to the relationship between a derived class and its base class, where the derived class is a subtype of the base class.

What is the difference between public, private, and protected access modifiers in inheritance?
A: Public members are accessible by all, private members are only accessible by the class that defines them, and protected members are accessible by the class that defines them and its derived classes.

What happens when a derived object is created in inheritance?
A: The base constructors are also called when a derived object is created.

What is the order of constructor definitions in inheritance?
A: Constructor definitions run in top-to-bottom order, with the base class constructor running first.

What is function overriding in inheritance?
A: Function overriding is when a derived class defines a function with the same prototype as a function in the base class, replacing the base class implementation with its own.

Multiple Inheritance

What is multiple inheritance?
A: Multiple inheritance is when a class is derived from more than one base class.

What is an example of multiple inheritance in C++?
A: An example of multiple inheritance in C++ is the ifstream class, which is derived from both istream and fstreambase.

What is the diamond problem in multiple inheritance?
A: The diamond problem is a problem that arises when a derived class is derived from two or more base classes that have a common base class.

Virtual Functions and Abstract Classes

What is a virtual function?
A: A virtual function is a function that can be overridden in a derived class and is called dynamically at runtime.

Why are virtual functions needed in inheritance?
A: Virtual functions are needed in inheritance because they allow for the correct function to be called at runtime based on the type of the object.

What is an abstract class?
A: An abstract class is a class that has at least one pure virtual function and cannot be instantiated.

Bitwise Operators

What is the purpose of bitwise operators?
A: Bitwise operators are used to manipulate individual bits of a variable.

What is the result of the XOR operation?
A: The result of the XOR operation is true if there is exactly one true (1) and one false (0).

What is the purpose of left and right shift operators?
A: Left shift operator shifts the bits of a variable to the left, while the right shift operator shifts the bits of a variable to the right.

What is the purpose of the complement operator?
A: The complement operator reverses the bits of a variable, changing all 1's to 0's and all

What are function templates and how do they work?
Function templates are functions that can work with multiple parameter types. When a function template is called, the compiler builds a separate function for each needed type, based on the calls used. Function templates provide an easy way to create overloaded functions without writing individual versions. However, operations performed inside the function need to be valid for types used in the calls.

What are class templates and how do they differ from function templates?
Class templates are an extension of the function template idea, allowing for the creation of a "generic" class where the type of item stored can vary. Each member function in the class is written as a function template. Again, operations used inside the class need to be valid for any type used to instantiate the class.

What is the syntax for declaring a template and instantiating objects with it?
The syntax for declaring a template is to use the keyword "template", followed by the template parameters in angle brackets "< >". There are two ways to declare the type parameter: "class" or "typename". An example of object instantiation with a template is "Stack< double > myStack;" where "Stack" is the name of the template and "double" is the type parameter.

What are some basic data structures, and how are they implemented?
Some basic data structures include the stack, queue, vector, and linked list. These data structures are often created to store data in useful ways, often beyond the built-in mechanisms like arrays. They are implemented using encapsulation of data structure inside an object, meaning details can be handled internally, and outside access through simpler interface. Often, it involves pointers and dynamic memory allocation inside the data structure. Templates are commonly used to make data structures more general and useful with more than one type of data.

What is recursion, and what are some example algorithms that use recursion?
Recursion is a technique of writing functions that calls itself. It involves extra activation records on function call stack. Recursion is sometimes an easier way to write a function. Some example algorithms that use recursion include factorial, Fibonacci, GCD, sorting, and binary search.

What is exception handling, and what are the basic syntax elements used in it?
Exception handling is a method of error-handling that is good for processing errors that must be handled in places other than where they occurred. The basic syntax elements used in exception handling include "try", "throw", and "catch". "try" is a label used for a block that encloses an area where exceptions might be thrown. "throw" is used to throw an exception and can "throw" an item like a variable or an object. "catch" blocks immediately follow the try blocks, and each catch can take one parameter, indicating the type of exception to be caught.

What is conditional compilation, and how is it used?
Conditional compilation is a preprocessor directive that can be used like if statements at the compiler level. It is used to check if symbols are defined and compile sections of code based on the result. The "#define" directive brings the symbol into existence, and the "#ifdef" and "#ifndef" directives check if the symbol is defined or not defined. The "#endif" directive is the ending of the "body" of the if-statement when using "#ifndef" or "#ifdef". It is often used for conditional compilation of platform-specific code, debug code, or different versions of a program.

Templates:

Q: How does the compiler build separate functions for each needed type in function templates?
A: When a function template is called with a particular type, the compiler generates a new function that replaces the template parameters with the actual type. This process is called instantiation, and the resulting functions are called function template specializations. Each specialization is only created if it is needed, based on the types used in the calls to the function.

Q: What are some benefits of using class templates?
A: Class templates provide a way to write a generic class that can work with different types of data. This can save time and effort compared to writing separate classes for each data type. Additionally, class templates can provide a type-safe way to work with data, since the compiler will check that the operations used inside the class are valid for any type used to instantiate the class.

Data Structures:

Q: What is the main difference between a stack and a queue?
A: The main difference between a stack and a queue is the order in which items are inserted and removed. In a stack, the last item inserted is the first one to be removed (FILO), while in a queue, the first item inserted is the first one to be removed (FIFO).

Q: What is the advantage of encapsulating a data structure inside an object?
A: Encapsulating a data structure inside an object provides a way to manage the data structure's implementation details internally, while providing a simpler interface for outside access. This can make the data structure more robust, since it can be designed to handle error conditions and prevent unauthorized access to its data.

Recursion:

Q: How does recursion differ from iteration?
A: Recursion involves calling a function from within itself, while iteration involves repeating a block of code using loops or other control structures. Recursion can be useful for solving certain types of problems, such as those that can be broken down into smaller sub-problems that are similar to the original problem.

Q: What is the activation record stack?
A: The activation record stack is a data structure used by the runtime system to keep track of the state of a program during function calls. Each time a function is called, a new activation record is created and pushed onto the stack, which contains information about the function's local variables, parameters, and return address. When the function returns, the activation record is popped off the stack and discarded.

Exception Handling:

Q: What is the purpose of the "throw list" in C++ exception handling?
A: The "throw list" is a mechanism in C++ that allows a function to specify which types of exceptions it can throw. This can be useful for providing information to the caller about the kinds of errors that might occur during execution. If a function throws an exception that is not listed in its throw list, the program will terminate with an error.

Conditional Compilation:

Q: What is the purpose of conditional compilation in C++?
A: Conditional compilation provides a way to selectively include or exclude sections of code based on certain conditions, such as the presence or absence of a particular macro definition. This can be useful for writing platform-independent code, or for optimizing performance by excluding code that is not needed for a particular build.

Write a function template that takes two parameters, an array and its size, and returns the sum of all elements in the array. The function should work with arrays of any type.

code : 
#include <iostream>
using namespace std;

template<class T>
class BSTNode {
public:
    T data;
    BSTNode<T> *left;
    BSTNode<T> *right;
    BSTNode(T value) {
        data = value;
        left = nullptr;
        right = nullptr;
    }
};

template<class T>
class BinarySearchTree {
public:
    BSTNode<T> *root;
    BinarySearchTree() {
        root = nullptr;
    }
    void insert(T value) {
        if (root == nullptr) {
            root = new BSTNode<T>(value);
            return;
        }
        BSTNode<T> *current = root;
        while (true) {
            if (value < current->data) {
                if (current->left == nullptr) {
                    current->left = new BSTNode<T>(value);
                    return;
                }
                current = current->left;
            }
            else {
                if (current->right == nullptr) {
                    current->right = new BSTNode<T>(value);
                    return;
                }
                current = current->right;
            }
        }
    }
    bool search(T value) {
        BSTNode<T> *current = root;
        while (current != nullptr) {
            if (value == current->data) {
                return true;
            }
            else if (value < current->data) {
                current = current->left;
            }
            else {
                current = current->right;
            }
        }
        return false;
    }
};

int main() {
    BinarySearchTree<int> bst;
    bst.insert(5);
    bst.insert(3);
    bst.insert(8);
    bst.insert(1);
    bst.insert(4);
    bst.insert(7);
    bst.insert(9);
    cout << bst.search(4) << endl; // outputs 1
    cout << bst.search(6) << endl; // outputs 0
    return 0;
}


Implement a class template for a binary search tree that stores integers. The class should include methods to insert and delete nodes, as well as to traverse the tree in order, pre-order, and post-order.

CODE : 

#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0) {
        return 1;
    }
    else {
        return n * factorial(n-1);
    }
}

int main() {
    int n = 5;
    int result = factorial(n);
    cout << "Factorial of " << n << " is " << result << endl;
    return 0;
}

Write a recursive function that takes an integer as input and returns the nth Fibonacci number. The function should throw an exception if the input is negative. You should use exception handling to catch and handle this error.

CODE : 

#include <iostream>
using namespace std;

template<typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    int x = 3;
    int y = 5;
    int result1 = add(x, y);
    double a = 2.5;
    double b = 3.7;
    double result2 = add(a, b);
    cout << "Sum of " << x << " and " << y << " is " << result1 << endl;
    cout << "Sum of " << a << " and " << b << " is " << result2 << endl;
    return 0;
}

